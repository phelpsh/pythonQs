{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Question 1\
\
I iterate through each letter in both the original string and the search string. The only tricky thing I found was letters repeated twice in the search string when not present twice in the original string were returning a false positive, hence the count functionality in lines 21-26.\
\
O(s*t) where s is the number of letters in one phrase and t the number of letters in the other. I realize this is probably not the most efficient way to accomplish this, but I am not a computer scientist and currently have a working solution.\
\
\
Question 2\
\
I created a separate function to keep track of the longest string as it stood, because this changed during the execution of the program. I also had to strip out spaces, which I assume follows the rules of palindromes if \'93nurses run\'94 meets the criteria. (i.e. if \'93nurses run\'94 is reversed, technically it should be \'93nur sesrun\'94 and would not be a palindrome.)\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 O(n) where n is number of letters/characters in the string. Again, I am sure there is a more efficient way to do this, but I have limited programming knowledge.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
Question 3 (minimum spanning tree)\
\
I thought this was the most difficult question of the five because of the complexity of moving parts and ensuring each vertex was accounted for only once while moving through all vertices. First I took all of the edges and ordered them by weight. Then I wrote a function checkCircular, which accepts an edge and examines whether either vertex of that edge is present in any other vertices which have already been examined. \
\
The timing is O(m log n), but I believe this solution using Prim\'92s algorithm, which grows the tree one edge at a time. I realize there are other algorithms and better ways to solve this.\
\
\
Question 4 (least common ancestor)\
\
I used an O(n) algorithm (where n is number of nodes) to find the least common ancestor by finding a path from the root to n1 and storing it, then doing the same for n2. Then I compared the two arrays (paths) and found the first common node in the paths, which is the least common ancestor.\
\
\
Question 5\
\
I created two classes: one a linked link and the other the nodes in the list. I used a sample from https://www.codefellows.org/blog/implementing-a-singly-linked-list-in-python/#sthash.OSXodfIP.dpuf as my basis and wrote an index method on the linked list which returned the item at m from the end. This was easy to implement because new items in a linked list are placed at the beginning (vice end as in an array).}